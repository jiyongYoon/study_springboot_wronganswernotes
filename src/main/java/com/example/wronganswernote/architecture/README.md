# 아키텍처에 대해서

---

## 1. 레이어드 아키텍처
- 유사한 기능들을 같은 계층으로 묶어 관리하는 방식의 아키텍처 구조
- 가장 흔히 사용되던 `Controller` - `Service` - `Repository` 레이어드가 이에 해당
- 보통 `추상화 없이 바로 구현체`를 사용하는 경우가 많다.

### 장점
- 이해하기 쉽다.

### 단점
**1. 어느 방식으로 접근해도 결과물이 애매하다.**
  - 상향식 접근법: `JpaRepository` ORM 기술에 종속
  - 하향식 접근법: `Rest API` 및 `스프링 프레임워크`에 종속
    - 이게 무슨말이냐하면, '도메인'에 대한 고민보다 '어떤 API가 필요한지' 등, 프레임워크에 맞춘 고민이 먼저 진행된다는 뜻.


> **만약 당신에게 어카운트 시스템을 만들어달라는 요청이 오면 어떤 고민을 할 것인가?** 
>   
> => 100 중 90은 `JPA 엔티티`, 5는 `API 인터페이스`를 떠올린다고 함.

우리는 어카운트 시스템에 필요한 `Use Case`. 즉, 기능을 먼저 정의해야 하고 이를 처리하는 `도메인`들과의 관계를 먼저 생각해야 한다.

**2. 동시 작업성이 떨어진다.**
- 한 기능의 `Controller` - `Service` - `Repository`의 기능개발이 얽혀있기 때문에 동시에 작업을 해야하는 인원이 매우 제한적이다. (절차지향 코드의 단점)

**3. 도메인의 능동성이 거의 없어진다.**
- 객체가 수동적이고 모든 코드가 메서드 위주로 돌아간다. (특히 Service 메서드)

**4. 테스트 하기 어려운 코드가 작성된다.**
- 반드시 그런것은 아니지만, 도메인 객체가 사라질수록 절차 지향적인 코드가 작성될 가능성이 높아지며, 따라서 테스트 코드를 작성하는데 필요한 객체들이 매우 많아져 코드 작성이 어려워진다.

> ### 의존성 역전 복기하기
> 
> 직접 구현체를 의존하지 않고, `interface`를 가운데 두는 것.
> 이를 통해 의존성의 방향이 반대로 역전되는 것을 말하며,
> 의존성 역전을 하는 이유는 
> `관심사를 분리시켜 서로에게 영향을 주고받는걸 없애기 위함`이다.


## 2. 헥사고날 아키텍처
- 레이어드 아키텍처에서 `도메인`을 살리고, `의존성 역전`을 시킨 구조가 `헥사고날 아키텍처`이다.
  ![image](https://github.com/jiyongYoon/study_java_standard/assets/98104603/9c5a42a7-0c70-44e1-9b21-a41a57253fe3)
- **내부 육각형**은 `순수한 도메인` 범위이고, 접근은 오직 `ServiceImpl` 한 방향에서만 가능해진다.
- **외부 육각형**은 `도메인` 범위이며, 개발자들이 핵심적으로 관심을 가지고 작업하는 부분이다.
  - `Controller`쪽인 `Rest API`나 `프레임워크` , `Repository`쪽인 `JPA` 등의 `ORM` 기술에 전혀 관심(의존성)이 없다.

![image](https://github.com/jiyongYoon/study_java_standard/assets/98104603/7ccb6386-e603-4d53-af02-063e30d3e6a1)
- 상향식으로 접근하여 개발하면 된다. 

---

> **학습을 하며 느낀점**
>
> 아키첵처에 정답이 있다기 보다는, `의존성 역전`과 `도메인 살리기`를 하는 이유에 대해 집중해야겠다.
> `테스트가 쉬운 의존관계`를 추구하는 것 같은데, 왜 '테스트 하기 쉬운 코드가 좋은 코드다'라는 말이 나오는지 이해가 되고 있다.


